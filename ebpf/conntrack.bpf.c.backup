#include "bpf_types_fix.h"
#include "bpf_types_fix.h"
#include <bpf/bpf_endian.h>
#include <bpf/bpf_helpers.h>
#include <linux/bpf.h>
#include <linux/if_ether.h>
#include <linux/if_packet.h>
#include <linux/if_vlan.h>
#include <linux/in.h>
#include <linux/ip.h>
#include <linux/ipv6.h>
#include <linux/pkt_cls.h>
#include <linux/tcp.h>
#include <linux/types.h>
#include <linux/udp.h>
#include <stdbool.h>
#include <stdint.h>
#include <sys/socket.h>

#include "conntrack_bpf_log.h"
#include "conntrack_common.h"
#include "conntrack_maps.h"
#include "conntrack_parser.h"
#include "conntrack_structs.h"

// We are making Configuration structure available to BPF program
const volatile struct conntrack_config conntrack_cfg = {};
int my_pid = 0;

// Helper Function

static __always_inline int swap_mac_addresses(void *data, void *data_end) {
  struct ethhdr *eth = data;

  // Bounds check
  if (data + sizeof(struct ethhdr) > data_end) {
    return -1;
  }

  // we are swapping source and MAC addresses
  unsigned char tmp_mac[6];
  __builtin_memcpy(tmp_mac, eth->h_source, 6);
  __builtin_memcpy(eth->h_source, eth->h_dest, 6);
  __builtin_memcpy(eth->h_dest, tmp_mac, 6);

  return 0;
}

static __always_inline int cleanup_expired_connection(struct ct_k *key,
                                                      struct ct_v *value,
                                                      uint64_t current_time) {
  if (value->ttl < current_time) {
    bpf_spin_unlock(&value->lock);
    bpf_log_debug("Connection expired, removing from map\n");
    bpf_map_delete_elem(&connections, key);
    goto TCP_MISS; // Expired and removed
  }
  return 0;
}

SEC("xdp")
int xdp_conntrack_prog(struct xdp_md *ctx) {
  int rc;
  struct packetHeaders pkt;

  void *data = (void *)(long)ctx->data;
  void *data_end = (void *)(long)ctx->data_end;

  bpf_printk("Packet received from interface (ifindex) %d",
             ctx->ingress_ifindex);

  if (parse_packet(data, data_end, &pkt) < 0) {
    bpf_log_debug("Failed to parse packet\n");
    return XDP_DROP;
  }

  bpf_log_debug("Packet parsed, now starting the conntrack.\n");

  struct ct_k key;
  __builtin_memset(&key, 0, sizeof(key));
  uint8_t ipRev = 0;
  uint8_t portRev = 0;

  if (pkt.srcIp <= pkt.dstIp) {
    key.srcIp = pkt.srcIp;
    key.dstIp = pkt.dstIp;
    ipRev = 0;
  } else {
    key.srcIp = pkt.dstIp;
    key.dstIp = pkt.srcIp;
    ipRev = 1;
  }

  key.l4proto = pkt.l4proto;

  if (pkt.srcPort < pkt.dstPort) {
    key.srcPort = pkt.srcPort;
    key.dstPort = pkt.dstPort;
    portRev = 0;
  } else if (pkt.srcPort > pkt.dstPort) {
    key.srcPort = pkt.dstPort;
    key.dstPort = pkt.srcPort;
    portRev = 1;
  } else {
    key.srcPort = pkt.srcPort;
    key.dstPort = pkt.dstPort;
    portRev = ipRev;
  }

  struct ct_v newEntry;
  __builtin_memset(&newEntry, 0, sizeof(newEntry));
  struct ct_v *value;

  uint64_t timestamp;
  timestamp = bpf_ktime_get_ns();

  /* == TCP  == */ // Fixes Here
  if (pkt.l4proto == IPPROTO_TCP) {
    bpf_log_debug("Processing TCP packet, flags: 0x%x\n", pkt.flags);

    // Handle RST packets - immediately close connections
    if ((pkt.flags & TCPHDR_RST) != 0) {
      bpf_log_debug("RST packet received\n");
      value = bpf_map_lookup_elem(&connections, &key);
      if (value != NULL) {
        bpf_log_debug("RST: Closing existing connection\n");
        bpf_map_delete_elem(&connections, &key);
      }
      pkt.connStatus = ESTABLISHED; // Allow RST to pass through
      goto PASS_ACTION;
    }

    // Look up existing connection
    value = bpf_map_lookup_elem(&connections, &key);
    if (value != NULL) {
      bpf_spin_lock(&value->lock);

      // Check if connection expired
      if (cleanup_expired_connection(&key, value, timestamp)) {
        bpf_spin_unlock(&value->lock);
        goto TCP_MISS; // Treat as new connection
      }

      // Determine packet direction
      if ((value->ipRev == ipRev) && (value->portRev == portRev)) {
        goto TCP_FORWARD;
      } else if ((value->ipRev != ipRev) && (value->portRev != portRev)) {
        goto TCP_REVERSE;
      } else {
        bpf_log_debug("Direction mismatch, treating as new connection\n");
        bpf_spin_unlock(&value->lock);
        goto TCP_MISS;
      }

    // Here we are focusing on Forward Direction Processing
    TCP_FORWARD:;
      bpf_log_debug("[FWD] Current state: %d, flags: 0x%x\n", value->state,
                    pkt.flags);

      if (value->state == SYN_SENT) {
        // Expecting pure SYN retransmission
        if (pkt.flags == TCPHDR_SYN) {
          value->ttl = timestamp + TCP_SYN_SENT;
          bpf_spin_unlock(&value->lock);
          pkt.connStatus = ESTABLISHED;
          goto PASS_ACTION;
        } else {
          pkt.connStatus = INVALID;
          bpf_spin_unlock(&value->lock);
          bpf_log_debug("[FWD] Invalid flags in SYN_SENT state: 0x%x\n",
                        pkt.flags);
          goto PASS_ACTION;
        }
      }

      if (value->state == SYN_RECV) {
        // Expecting ACK to complete handshake
        if (pkt.flags == TCPHDR_ACK && pkt.ackN == value->sequence) {
          value->state = ESTABLISHED;
          value->ttl = timestamp + TCP_ESTABLISHED;
          bpf_spin_unlock(&value->lock);
          bpf_log_debug("[FWD] Handshake complete: SYN_RECV -> ESTABLISHED\n");
          pkt.connStatus = ESTABLISHED;
          goto PASS_ACTION;
        } else {
          pkt.connStatus = INVALID;
          bpf_spin_unlock(&value->lock);
          bpf_log_debug("[FWD] Invalid ACK in SYN_RECV state. Expected ack: "
                        "%u, got: %u, flags: 0x%x\n",
                        value->sequence, pkt.ackN, pkt.flags);
          goto PASS_ACTION;
        }
      }

      if (value->state == ESTABLISHED) {
        if (pkt.flags & TCPHDR_FIN) {
          // Start connection termination
          value->state = FIN_WAIT_1;
          value->ttl = timestamp + TCP_FIN_WAIT;
          value->sequence = pkt.seqN + 1; // Expected ACK for FIN
          bpf_spin_unlock(&value->lock);
          bpf_log_debug(
              "[FWD] Starting termination: ESTABLISHED -> FIN_WAIT_1\n");
          pkt.connStatus = ESTABLISHED;
          goto PASS_ACTION;
        } else {
          /* Data packet */
          value->ttl = timestamp + TCP_ESTABLISHED;
          bpf_spin_unlock(&value->lock);
          pkt.connStatus = ESTABLISHED;
          goto PASS_ACTION;
        }
      }

      if (value->state == FIN_WAIT_1) {
        // Should not receive packets in forward direction in FIN_WAIT_1
        value->ttl = timestamp + TCP_FIN_WAIT;
        bpf_spin_unlock(&value->lock);
        pkt.connStatus = ESTABLISHED;
        goto PASS_ACTION;
      }

      if (value->state == FIN_WAIT_2) {
        // Still in closing, update timer
        value->ttl = timestamp + TCP_FIN_WAIT;
        bpf_spin_unlock(&value->lock);
        pkt.connStatus = ESTABLISHED;
        goto PASS_ACTION;
      }

      if (value->state == LAST_ACK || value->state == TIME_WAIT) {
        // Connection closing
        bpf_spin_unlock(&value->lock);
        pkt.connStatus = ESTABLISHED;
        goto PASS_ACTION;
      }

      bpf_spin_unlock(&value->lock);
      bpf_log_debug("[FWD] Unhandled state: %d, flags: 0x%x\n", value->state,
                    pkt.flags);
      pkt.connStatus = ESTABLISHED;
      goto PASS_ACTION;

      // Reverse Direction Processing
    TCP_REVERSE:;
      bpf_log_debug("[REV] Current state: %d, flags: 0x%x\n", value->state,
                    pkt.flags);

      if (value->state == SYN_SENT) {
        // Expecting SYN+ACK response
        if ((pkt.flags & (TCPHDR_SYN | TCPHDR_ACK)) ==
                (TCPHDR_SYN | TCPHDR_ACK) &&
            pkt.ackN == value->sequence) {
          value->state = SYN_RECV;
          value->ttl = timestamp + TCP_SYN_RECV;
          value->sequence = pkt.seqN + 1; // Expected ACK for SYN
          bpf_spin_unlock(&value->lock);
          bpf_log_debug("[REV] SYN+ACK received: SYN_SENT -> SYN_RECV\n");
          pkt.connStatus = ESTABLISHED;
          goto PASS_ACTION;
        } else {
          pkt.connStatus = INVALID;
          bpf_spin_unlock(&value->lock);
          bpf_log_debug(
              "[REV] Invalid SYN+ACK. Expected ack: %u, got: %u, flags: 0x%x\n",
              value->sequence, pkt.ackN, pkt.flags);
          goto PASS_ACTION;
        }
      }

      if (value->state == SYN_RECV) {
        // Retransmitted SYN+ACK
        if ((pkt.flags & (TCPHDR_SYN | TCPHDR_ACK)) ==
            (TCPHDR_SYN | TCPHDR_ACK)) {
          value->ttl = timestamp + TCP_SYN_RECV;
          bpf_spin_unlock(&value->lock);
          pkt.connStatus = ESTABLISHED;
          goto PASS_ACTION;
        } else {
          pkt.connStatus = INVALID;
          bpf_spin_unlock(&value->lock);
          goto PASS_ACTION;
        }
      }

      if (value->state == ESTABLISHED) {
        if (pkt.flags & TCPHDR_FIN) {
          // Peer initiating close
          value->state =
              FIN_WAIT_1; // We'll transition to CLOSE_WAIT when we send ACK
          value->ttl = timestamp + TCP_FIN_WAIT;
          value->sequence = pkt.seqN + 1; // Expected ACK for FIN
          bpf_spin_unlock(&value->lock);
          bpf_log_debug("[REV] Peer closing: ESTABLISHED -> FIN_WAIT_1\n");
          pkt.connStatus = ESTABLISHED;
          goto PASS_ACTION;
        } else {
          /* Data packet from peer */
          value->ttl = timestamp + TCP_ESTABLISHED;
          bpf_spin_unlock(&value->lock);
          pkt.connStatus = ESTABLISHED;
          goto PASS_ACTION;
        }
      }

      if (value->state == FIN_WAIT_1) {
        if (pkt.flags == TCPHDR_ACK) {
          // ACK for our FIN
          value->state = FIN_WAIT_2;
          value->ttl = timestamp + TCP_FIN_WAIT;
          bpf_spin_unlock(&value->lock);
          bpf_log_debug("[REV] ACK for FIN: FIN_WAIT_1 -> FIN_WAIT_2\n");
          pkt.connStatus = ESTABLISHED;
          goto PASS_ACTION;
        } else if (pkt.flags & TCPHDR_FIN) {
          // Simultaneous close
          value->state = LAST_ACK;
          value->ttl = timestamp + TCP_LAST_ACK;
          value->sequence = pkt.seqN + 1;
          bpf_spin_unlock(&value->lock);
          bpf_log_debug("[REV] Simultaneous close: FIN_WAIT_1 -> LAST_ACK\n");
          pkt.connStatus = ESTABLISHED;
          goto PASS_ACTION;
        } else {
          value->ttl = timestamp + TCP_FIN_WAIT;
          bpf_spin_unlock(&value->lock);
          pkt.connStatus = ESTABLISHED;
          goto PASS_ACTION;
        }
      }

      if (value->state == FIN_WAIT_2) {
        if (pkt.flags & TCPHDR_FIN) {
          // Final FIN from peer
          value->state = TIME_WAIT;
          value->ttl = timestamp + TCP_LAST_ACK;
          bpf_spin_unlock(&value->lock);
          bpf_log_debug("[REV] Final FIN: FIN_WAIT_2 -> TIME_WAIT\n");
          pkt.connStatus = ESTABLISHED;
          goto PASS_ACTION;
        } else {
          value->ttl = timestamp + TCP_FIN_WAIT;
          bpf_spin_unlock(&value->lock);
          pkt.connStatus = ESTABLISHED;
          goto PASS_ACTION;
        }
      }

      if (value->state == LAST_ACK) {
        if (pkt.flags == TCPHDR_ACK && pkt.seqN == value->sequence) {
          // Final ACK - connection closed
          bpf_spin_unlock(&value->lock);
          bpf_map_delete_elem(&connections, &key);
          bpf_log_debug("[REV] Connection closed: LAST_ACK -> CLOSED\n");
          pkt.connStatus = ESTABLISHED;
          goto PASS_ACTION;
        } else {
          value->ttl = timestamp + TCP_LAST_ACK;
          bpf_spin_unlock(&value->lock);
          pkt.connStatus = ESTABLISHED;
          goto PASS_ACTION;
        }
      }

      if (value->state == TIME_WAIT) {
        // Connection in TIME_WAIT, allow packets through
        bpf_spin_unlock(&value->lock);
        pkt.connStatus = ESTABLISHED;
        goto PASS_ACTION;
      }

      bpf_spin_unlock(&value->lock);
      bpf_log_debug("[REV] Unhandled state: %d, flags: 0x%x\n", value->state,
                    pkt.flags);
      pkt.connStatus = ESTABLISHED;
      goto PASS_ACTION;
    }

  // New TCP Connection Handling
  TCP_MISS:;
    bpf_log_debug("New TCP connection attempt, flags: 0x%x\n", pkt.flags);

    if (pkt.flags == TCPHDR_SYN) {
      newEntry.state = SYN_SENT;
      newEntry.ttl = timestamp + TCP_SYN_SENT;
      newEntry.sequence = pkt.seqN + 1; // Expected Ack

      newEntry.ipRev = ipRev;
      newEntry.portRev = portRev;

      bpf_map_update_elem(&connections, &key, &newEntry, BPF_ANY);
      bpf_log_debug(
          "New TCP connection created: %u.%u.%u.%u:%u -> %u.%u.%u.%u:%u\n",
          (pkt.srcIp) & 0xFF, (pkt.srcIp >> 8) & 0xFF, (pkt.srcIp >> 16) & 0xFF,
          (pkt.srcIp >> 24) & 0xFF, bpf_ntohs(pkt.srcPort), (pkt.dstIp) & 0xFF,
          (pkt.dstIp >> 8) & 0xFF, (pkt.dstIp >> 16) & 0xFF,
          (pkt.dstIp >> 24) & 0xFF, bpf_ntohs(pkt.dstPort));
      pkt.connStatus = NEW;
      goto PASS_ACTION;
    } else {
      // Validation failed
      bpf_log_debug("Invalid packet to start TCP connection. Expected SYN, got "
                    "flags: 0x%x\n",
                    pkt.flags);
      pkt.connStatus = INVALID;
      goto PASS_ACTION;
    }
  }

  // UDP Processing (Enhancement)
  else if (pkt.l4proto == IPPROTO_UDP) {
    bpf_log_debug("Processing UDP packet: %u.%u.%u.%u:%u -> %u.%u.%u.%u:%u\n",
                  (pkt.srcIp) & 0xFF, (pkt.srcIp >> 8) & 0xFF,
                  (pkt.srcIp >> 16) & 0xFF, (pkt.srcIp >> 24) & 0xFF,
                  bpf_ntohs(pkt.srcPort), (pkt.dstIp) & 0xFF,
                  (pkt.dstIp >> 8) & 0xFF, (pkt.dstIp >> 16) & 0xFF,
                  (pkt.dstIp >> 24) & 0xFF, bpf_ntohs(pkt.dstPort));

    value = bpf_map_lookup_elem(&connections, &key);
    if (value != NULL) {
      // Existing UDP flow
      bpf_spin_lock(&value->lock);

      // Check if flow expired
      if (cleanup_expired_connection(&key, value, timestamp)) {
        bpf_spin_unlock(&value->lock);
        goto UDP_NEW_FLOW; // Treat as new flow
      }

      // Update flow timestamp and validate direction */
      if ((value->ipRev == ipRev) && (value->portRev == portRev)) {
        // Forward direction
        value->ttl = timestamp + UDP_FLOW_TIMEOUT;
        bpf_spin_unlock(&value->lock);
        bpf_log_debug("[UDP-FWD] Updated existing flow timeout\n");
        pkt.connStatus = ESTABLISHED;
        goto PASS_ACTION;
      } else if ((value->ipRev != ipRev) && (value->portRev != portRev)) {
        // Reverse direction - bidirectional flow
        value->ttl = timestamp + UDP_ESTABLISHED_TIMEOUT;
        value->state = ESTABLISHED; // Mark as bidirectional
        bpf_spin_unlock(&value->lock);
        bpf_log_debug("[UDP-REV] Bidirectional flow established\n");
        pkt.connStatus = ESTABLISHED;
        goto PASS_ACTION;
      } else {
        // Direction mismatch - treat as new flow
        bpf_spin_unlock(&value->lock);
        goto UDP_NEW_FLOW;
      }
    }

  UDP_NEW_FLOW:;
    // Create new UDP flow entry
    bpf_log_debug("Creating new UDP flow\n");

    newEntry.state = NEW; // Start as unidirectional
    newEntry.ttl = timestamp + UDP_FLOW_TIMEOUT;
    newEntry.sequence = 0; // Not used for UDP
    newEntry.ipRev = ipRev;
    newEntry.portRev = portRev;

    // Insert new flow into map
    int result = bpf_map_update_elem(&connections, &key, &newEntry, BPF_ANY);
    if (result != 0) {
      bpf_log_err("Failed to insert new UDP flow (error: %d)\n", result);
      pkt.connStatus = INVALID;
    } else {
      bpf_log_debug("New UDP flow created successfully\n");
      pkt.connStatus = NEW;
    }
    goto PASS_ACTION;

    // UNSUPPORTED PROTOCOLS
  } else {
    bpf_log_debug("Unsupported L4 protocol: %d\n", pkt.l4proto);
    pkt.connStatus = INVALID;
    goto PASS_ACTION;
  }

PASS_ACTION:;
  // We will update the statistics
  struct pkt_md *md;
  __u32 md_key = 0;
  md = bpf_map_lookup_elem(&metadata, &md_key);
  if (md == NULL) {
    bpf_log_err("No elements found in metadata map\n");
    goto DROP;
  }

  uint16_t pkt_len = (uint16_t)(data_end - data);

  __sync_fetch_and_add(&md->cnt, 1);
  __sync_fetch_and_add(&md->bytes_cnt, pkt_len);

  if (pkt.connStatus == INVALID) {
    bpf_log_err("Connection status is invalid, dropping packet\n");
    goto DROP;
  }

  // Important Fix: We are swapping MAC addresses before redirect
  if (swap_mac_addresses(data, data_end) < 0) {
    bpf_log_err("Failed to swap MAC addresses\n");
    goto DROP;
  }
  if (ctx->ingress_ifindex == conntrack_cfg.if_index_if1) {
    bpf_log_debug("Redirecting packet: IF1 (%d) -> IF2 (%d)\n",
                  conntrack_cfg.if_index_if1, conntrack_cfg.if_index_if2);
    return bpf_redirect(conntrack_cfg.if_index_if2, 0);
  } else if (ctx->ingress_ifindex == conntrack_cfg.if_index_if2) {
    bpf_log_debug("Redirecting packet: IF2 (%d) -> IF1 (%d)\n",
                  conntrack_cfg.if_index_if2, conntrack_cfg.if_index_if1);
    return bpf_redirect(conntrack_cfg.if_index_if1, 0);
  } else {
    bpf_log_err("Unknown interface %d. Expected %d or %d\n",
                ctx->ingress_ifindex, conntrack_cfg.if_index_if1,
                conntrack_cfg.if_index_if2);
    goto DROP;
  }

DROP:;
  bpf_log_debug("Dropping packet!\n");
  return XDP_DROP;
}

char LICENSE[] SEC("license") = "Dual BSD/GPL";
